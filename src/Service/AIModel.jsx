import { GoogleGenerativeAI } from "@google/generative-ai";
  
  const apiKey = import.meta.env.VITE_GOOGLE_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash-exp",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
  };
  
  
  export  const chatSession = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Here's a Python function that checks whether a word is a palindrome.\nAdd 10 different unit tests for this snippet with comments. Follow up with a short explanation of what was done.\n\n\n```\ndef is_palindrome(word):\n  \"\"\"\n  Checks whether a word is a palindrome.\n\n  Args:\n    word: The word to check.\n\n  Returns:\n    True if the word is a palindrome, False otherwise.\n  \"\"\"\n\n  # Convert the word to lowercase and remove non-alphanumeric characters.\n  word = ''.join(char.lower() for char in word if char.isalnum())\n\n  # Check if the word is the same forwards and backwards.\n  return word == word[::-1]\n```"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```python\nimport unittest\n\ndef is_palindrome(word):\n  \"\"\"\n  Checks whether a word is a palindrome.\n\n  Args:\n    word: The word to check.\n\n  Returns:\n    True if the word is a palindrome, False otherwise.\n  \"\"\"\n\n  # Convert the word to lowercase and remove non-alphanumeric characters.\n  word = ''.join(char.lower() for char in word if char.isalnum())\n\n  # Check if the word is the same forwards and backwards.\n  return word == word[::-1]\n\nclass TestIsPalindrome(unittest.TestCase):\n\n    def test_valid_palindrome_lowercase(self):\n        # Test case 1: Valid palindrome with lowercase letters.\n        self.assertTrue(is_palindrome(\"madam\"))\n\n    def test_valid_palindrome_mixedcase(self):\n        # Test case 2: Valid palindrome with mixed case letters.\n        self.assertTrue(is_palindrome(\"Racecar\"))\n\n    def test_valid_palindrome_with_spaces(self):\n        # Test case 3: Valid palindrome with spaces and punctuation.\n        self.assertTrue(is_palindrome(\"A man, a plan, a canal: Panama\"))\n\n    def test_valid_palindrome_empty_string(self):\n        # Test case 4: Empty string (should be considered a palindrome)\n        self.assertTrue(is_palindrome(\"\"))\n\n    def test_not_palindrome_simple(self):\n        # Test case 5: Simple word that is not a palindrome.\n        self.assertFalse(is_palindrome(\"hello\"))\n\n    def test_not_palindrome_with_punctuation(self):\n        # Test case 6: Word with punctuation that is not a palindrome.\n        self.assertFalse(is_palindrome(\"hello!\"))\n\n    def test_not_palindrome_mixed_case(self):\n         # Test case 7: Word with mixed case that is not a palindrome\n        self.assertFalse(is_palindrome(\"HelLo\"))\n\n    def test_single_character_palindrome(self):\n        # Test case 8: Single character is a palindrome.\n        self.assertTrue(is_palindrome(\"a\"))\n    \n    def test_palindrome_with_numbers(self):\n        # Test case 9: A palindrome that contains numbers.\n        self.assertTrue(is_palindrome(\"121\"))\n    \n    def test_not_palindrome_with_numbers(self):\n        # Test case 10: A non-palindrome with numbers.\n        self.assertFalse(is_palindrome(\"123\"))\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n**Explanation:**\n\nThe code implements a `TestIsPalindrome` class which inherits from `unittest.TestCase`. This class contains 10 different test methods, each designed to verify a specific aspect of the `is_palindrome` function. Each test method uses `self.assertTrue` or `self.assertFalse` to assert whether the result of calling `is_palindrome` matches the expected outcome. \n\nHere's a breakdown of the test cases:\n\n1.  **`test_valid_palindrome_lowercase`**: Tests a basic lowercase palindrome (\"madam\").\n2.  **`test_valid_palindrome_mixedcase`**: Tests a palindrome with mixed-case letters (\"Racecar\"). This checks if case-insensitivity is handled correctly.\n3.  **`test_valid_palindrome_with_spaces`**: Tests a more complex palindrome with spaces and punctuation (\"A man, a plan, a canal: Panama\"). This tests if non-alphanumeric characters are ignored correctly.\n4.  **`test_valid_palindrome_empty_string`**: Tests an empty string (\"\").  Empty strings are often considered palindromes.\n5.  **`test_not_palindrome_simple`**: Tests a simple non-palindrome (\"hello\").\n6.  **`test_not_palindrome_with_punctuation`**: Tests a non-palindrome with punctuation (\"hello!\").\n7.  **`test_not_palindrome_mixed_case`**: Tests a non-palindrome with mixed-case letters (\"HelLo\").\n8. **`test_single_character_palindrome`**: Tests a single-character word (\"a\") which is a palindrome.\n9. **`test_palindrome_with_numbers`**: Tests a palindrome that contains numbers (\"121\").\n10. **`test_not_palindrome_with_numbers`**: Tests a non-palindrome that contains numbers (\"123\").\n\nThe `if __name__ == '__main__':` block ensures that the tests are run when the script is executed directly. `unittest.main()` is used to discover and run the tests defined in the `TestIsPalindrome` class.\n"},
          ],
        },
        {
          role: "user",
          parts: [
            {text: "AI TRAVERAL PLANNER 3.0"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "Okay, let's brainstorm the features and functionality of \"AI Traversal Planner 3.0\"! I'll structure this as a feature list, considering a few different angles of what a traversal planner might do.\n\n**Core Functionality & Features:**\n\n1.  **Intelligent Route Generation:**\n    *   **Multi-Modal Support:** Plan routes that combine walking, driving, cycling, public transit, and even unconventional modes (e.g., scooters, boats, cable cars).\n    *   **Real-Time Data Integration:** Consider traffic, public transit delays, weather conditions, and road closures to dynamically adjust routes.\n    *   **Optimization Goals:** Allow users to specify optimization criteria, such as:\n        *   **Shortest time:** Fastest route possible.\n        *   **Shortest distance:** Minimize overall distance.\n        *   **Cheapest:** Opt for cost-effective transportation options.\n        *   **Most Scenic:** Prioritize routes with pleasant views.\n        *   **Accessibility:** Factor in mobility requirements (wheelchair access, etc.).\n    *   **Dynamic Rerouting:** Offer real-time updates and alternative route options based on changes in conditions.\n    *   **Custom Waypoints:** Allow users to add specific stops or points of interest along a route.\n\n2.  **Contextual Awareness:**\n    *   **Personalized Preferences:** Learn user travel habits, preferred modes, and typical destinations to offer customized suggestions.\n    *   **Time of Day/Week Consideration:** Factor in peak hours, rush hour, and public transit schedules.\n    *   **Calendar Integration:**  Sync with user calendars to plan trips based on scheduled appointments or events.\n    *   **Location-Based Recommendations:** Suggest points of interest, nearby restaurants, or services relevant to the user's location and itinerary.\n\n3.  **User Interface and Experience:**\n    *   **Intuitive Map Interface:** Display clear, interactive maps that allow easy route visualization and modification.\n    *   **Voice-Controlled Navigation:** Allow hands-free route planning and navigation.\n    *   **Augmented Reality Overlay:** Overlay navigation cues and information onto the real world through the user's device camera.\n    *   **Offline Maps and Navigation:** Support navigation even without an internet connection.\n    *   **Multi-Device Syncing:** Enable seamless access to saved routes and settings across different devices.\n\n4.  **Data and Analysis:**\n    *   **Travel History Tracking:** Record past trips, allowing users to track their travel patterns and analyze their travel habits.\n    *   **Performance Metrics:** Provide data on time saved, distance traveled, cost of travel, and other relevant metrics.\n    *   **Data Export:** Allow users to export route data for use in other applications.\n    *   **Crowdsourced Data:** Utilize anonymized user data to improve route accuracy and real-time information.\n\n5.  **Advanced AI Features:**\n    *   **Predictive Modeling:** Use machine learning to predict travel times more accurately and anticipate potential disruptions.\n    *   **Contextual Understanding:** Use Natural Language Processing (NLP) to understand complex user requests and respond intelligently.\n    *   **Proactive Recommendations:** Suggest optimal travel plans based on predicted user needs and current conditions.\n    *   **Adaptable Learning:** Continuously learn and improve based on user feedback and real-world data.\n\n**Possible \"3.0\" Enhancements:**\n\n*   **Group Travel Planning:** Seamlessly coordinate routes and plans for groups of people, taking into account everyone's preferences and schedules.\n*   **Integration with IoT Devices:** Interact with smart home devices to pre-heat the car, turn on the lights at home, or start coffee when the user is nearing their destination.\n*   **Emergency Response Integration:** Provide guidance and support during emergencies, including rerouting based on emergency situations and access to emergency contact information.\n*   **Sustainable Travel Options:**  Prioritize routes that minimize environmental impact, promoting cycling, walking, and public transit options.\n*   **Customizable AI Agents:** Allow users to define personalized AI agents that manage their travel planning and preferences.\n\n**Key Considerations:**\n\n*   **Data Privacy:** Handle user data responsibly and transparently.\n*   **Security:** Ensure secure communication and data storage.\n*   **Scalability:** Design the system to handle a large number of users and data points.\n*   **Accuracy:**  Maintain a high degree of accuracy in route calculations and real-time information.\n\n**Let's Discuss:**\n\n*   What specific aspects are you most interested in focusing on?\n*   What are the key use cases that the AI Traversal Planner 3.0 should address?\n*   What are the most important features for an \"AI-powered\" travel planner?\n\nBy discussing these points, we can refine and tailor the features of AI Traversal Planner 3.0 to be truly innovative and valuable!\n"},
          ],
        },
        {
          role: "user",
          parts: [
            {text: "GEMINI API\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "Okay, let's talk about the Gemini API in the context of the \"AI Traversal Planner 3.0.\" We can explore how the Gemini API (assuming you're referring to Google's Gemini models) could be integrated to enhance the planner's capabilities.\n\n**How the Gemini API Could Elevate AI Traversal Planner 3.0**\n\nHere's a breakdown of potential Gemini API integrations and the benefits they could provide:\n\n1.  **Enhanced Natural Language Understanding (NLU) for Route Planning:**\n\n    *   **Feature:** Use Gemini's advanced NLP capabilities to understand complex and nuanced user requests for routes.\n    *   **Example:**\n        *   Instead of just \"Take me to the airport,\" a user could say, \"Find the fastest route to the airport that avoids highways during rush hour and allows for a 20-minute stop for coffee.\"\n        *   Or, \"Plan a scenic bike route from downtown to the park, passing by that cool mural I saw last week.\"\n    *   **Benefit:** More flexible and intuitive route planning through natural language, reducing reliance on rigid menus or forms.\n    *   **Gemini API Endpoint:** Utilize Gemini's text-to-text API for understanding user intent and extracting relevant information.\n\n2.  **Intelligent Contextual Understanding and Adaptation:**\n\n    *   **Feature:** Use Gemini to analyze user history, calendar events, and real-time information to generate personalized and contextually relevant route suggestions.\n    *   **Example:**\n        *   If a user is known to prefer public transportation, the planner will prioritize those options.\n        *   If the user has a meeting scheduled, the planner can provide time-sensitive route suggestions.\n        *   If it detects inclement weather, it could suggest an indoor route or mode of transportation.\n    *   **Benefit:** The planner becomes more proactive and anticipatory, providing tailored recommendations even before the user explicitly asks.\n    *   **Gemini API Endpoint:** Combine Gemini's text-to-text API with access to user data and real-time data to generate smart suggestions.\n\n3.  **Generating More Creative and Personalized Route Options:**\n\n    *   **Feature:** Leverage Gemini's creativity and generative capabilities to suggest less obvious, more customized route alternatives based on user preferences.\n    *   **Example:**\n        *   If the user wants a \"scenic\" route, Gemini can analyze mapping data, satellite images, and user reviews to suggest a route with beautiful views that goes beyond the standard \"scenic route\" option.\n        *   Suggest \"off the beaten path\" routes based on user interests, like routes that go through historical districts or past local art galleries.\n    *   **Benefit:** Expands beyond basic mapping to offer truly personalized and interesting travel experiences.\n    *   **Gemini API Endpoint:** Explore Gemini's text generation and code generation APIs in conjunction with geographic data to create tailored itineraries.\n\n4.  **Enhanced Summarization of Route Information:**\n\n    *   **Feature:** Use Gemini to summarize key points of a travel route, including important landmarks, transfer points, and travel time estimates.\n    *   **Example:**\n        *   Instead of a long list of directions, Gemini could provide a concise summary like: \"Take the train from Station A, transfer at Station B to Line 2. Get off at Station C, about a 5-minute walk from your destination. Total travel time is 45 minutes.\"\n    *   **Benefit:** Makes it easier for users to quickly understand the key details of a travel plan.\n    *   **Gemini API Endpoint:** Use Gemini's text summarization capabilities to concisely present complex route information.\n\n5.  **Multi-Turn Conversations and Problem Solving:**\n\n    *   **Feature:** Utilize Gemini's conversational capabilities to enable users to ask follow-up questions and interact with the planner in a more natural way.\n    *   **Example:**\n        *   User: \"Is there a bike rental station near the park?\"\n        *   Planner: \"Yes, there are a couple of bike stations within a 5-minute walk of the park entrance. Would you like me to add that to your route?\"\n    *   **Benefit:** Enables dynamic interaction, allows users to refine their plans based on additional needs, and makes the planning process more user-friendly.\n    *   **Gemini API Endpoint:** Employ Gemini's conversational API to power seamless multi-turn interactions and address user queries.\n\n6. **Integration with External Data Sources (Using Function Calling):**\n    * **Feature:** Use Gemini's function calling to fetch real-time data like traffic updates, public transportation schedules, availability of nearby scooter/bike rentals, and weather updates.\n    * **Example:**\n        * When a user asks for the fastest route, the system can use Gemini to figure out the most relevant external data to fetch, like the real-time traffic situation for different routes.\n    * **Benefit:** Provides the most up-to-date and accurate route options by leveraging the latest available information.\n    * **Gemini API Endpoint:** Utilize the function calling capability to connect Gemini to APIs for retrieving real-time data.\n\n**Implementation Considerations:**\n\n*   **API Quotas and Costs:** Be mindful of usage limits and costs associated with the Gemini API.\n*   **Latency:** Optimize integration to ensure quick response times for route planning and navigation.\n*   **Data Privacy and Security:** Follow best practices for handling user data and API keys securely.\n*   **Error Handling:** Design robust error handling to ensure the planner works smoothly even when the Gemini API doesn't respond as expected.\n\n**In Summary:**\n\nThe Gemini API can be a powerful tool for enhancing the \"AI Traversal Planner 3.0\". By leveraging its NLP, generation, and conversational capabilities, the planner can become more intelligent, personalized, and user-friendly, ultimately providing more intuitive and delightful travel experiences.\n\nDoes this give you a good starting point for thinking about Gemini integration? What aspects are you most excited to explore further?\n"},
          ],
        },
      ],
    });
 
  
  
